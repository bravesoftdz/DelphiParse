unit DelphiParse.Objects;

interface

uses DelphiParse, DelphiParse.Interfaces, System.JSON,
  System.Generics.Collections, DelphiParse.Consts,
  DelphiParse.Query;

type
  TParseObjects = class(TInterfacedObject, IParseObject)
  private
    FClassName: string;
    Obj: TJSonObject;
    Parse: IDelphiParse;
    Query: IParseQuery;
    procedure Add(Key, Value: Variant); overload;
    function Get(Params: TDictionary<string, string>): string;
  public
    constructor Create(ClassName: string);
    destructor Destroy; override;

    function SaveInBackGround(): string;
    function GetAllInBackGround(): string;
    function DeleteInBackGround(ObjectId: string): string;
  end;

implementation

uses
  System.SysUtils;

{ TDelphiParseObjects }

constructor TParseObjects.Create(ClassName: string);
begin
  inherited Create;
  FClassName := ClassName;
  Obj := TJSONObject.Create;
  Parse := TDelphiParse.Create;
  Query := TParseQuery.Create;
end;

destructor TParseObjects.Destroy;
begin
  Obj.Free;
  inherited;
end;

function TParseObjects.Get(Params: TDictionary<string, string>): string;
begin
  Result := Parse.Get(['classes', FClassName], nil, Params).ResponseAsString();
end;

function TParseObjects.GetAllInBackGround: string;
begin
  Result := Parse.Get(['classes', FClassName]).ResponseAsString();
end;

procedure TParseObjects.Add(Key, Value: Variant);
begin
  Obj.AddPair(Key, Value);
end;

function TParseObjects.SaveInBackGround: string;
begin
  if (Obj.Count = 0) then
    raise Exception.Create('Objeto JSON não preenchido!');
  Result := Parse.Post(['classes', FClassName], Obj).ResponseAsString();
end;

function TParseObjects.DeleteInBackGround(ObjectId: string): string;
begin
  if (ObjectId = '') then
    raise Exception.Create('ObjectId não informado!');
  Result := Parse.Post(['classes', FClassName, ObjectId]).ResponseAsString();
end;

end.
